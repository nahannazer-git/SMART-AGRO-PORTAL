{% extends "base.html" %}

{% block title %}Chat with {{ farmer.full_name }} - Expert Portal{% endblock %}

{% block extra_css %}
<style>
    .chat-messages {
        height: 500px;
        overflow-y: auto;
        background-color: #f8f9fa;
        padding: 20px;
        border-radius: 10px;
    }

    .message {
        margin-bottom: 15px;
        padding: 10px 15px;
        border-radius: 10px;
        max-width: 70%;
    }

    .message.expert {
        background-color: #198754;
        color: white;
        margin-left: auto;
        text-align: right;
    }

    .message.farmer {
        background-color: #0d6efd;
        color: white;
    }

    .message-time {
        font-size: 0.75rem;
        opacity: 0.8;
    }

    .chat-image img {
        max-width: 250px;
        max-height: 250px;
        border-radius: 8px;
        margin-top: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
    }
</style>
{% endblock %}

{% block content %}
<nav class="navbar navbar-expand-lg navbar-dark bg-success mb-4">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('expert.chat_list') }}">
            <i class="bi bi-arrow-left"></i> Back to Chat List
        </a>
    </div>
</nav>

<div class="container">
    <div class="row">
        <div class="col-12">
            <div class="card shadow-lg border-0">
                <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                    <div>
                        <h5 class="mb-0">
                            <i class="bi bi-person"></i> {{ farmer.full_name }}
                        </h5>
                        <small>{{ farmer.email }}</small>
                    </div>
                </div>

                <div class="card-body p-0">
                    <div class="chat-messages" id="chatMessages">
                        {% if messages %}
                        {% for msg in messages %}
                        <div class="message {{ msg.sender_role }}">
                            <div>{{ msg.message }}</div>
                            {% if msg.image_path %}
                            <div class="mt-2"><img src="{{ url_for('static', filename='') }}{{ msg.image_path }}"
                                    alt="Chat image" class="img-fluid rounded" style="max-height:200px;"></div>
                            {% endif %}
                            <div class="message-time">{{ msg.created_at.strftime('%Y-%m-%d %H:%M') }}</div>
                        </div>
                        {% endfor %}
                        {% else %}
                        <div class="text-center text-muted py-5">
                            <i class="bi bi-chat-left-text" style="font-size: 3rem;"></i>
                            <p class="mt-3">No messages yet. Start the conversation!</p>
                        </div>
                        {% endif %}
                    </div>

                    <div class="card-footer">
                        <form method="POST" id="chatForm" class="d-flex gap-2 align-items-center" enctype="multipart/form-data">
                            <input type="text" name="message" id="messageInput" class="form-control"
                                placeholder="Type your message...">
                            <div id="imagePreviewContainer" class="d-none" style="position: relative;">
                                <img id="imagePreview" src="" alt="Preview" style="max-height: 50px; max-width: 50px; border-radius: 5px;">
                                <button type="button" class="btn btn-sm btn-danger" id="clearImageBtn" style="position: absolute; top: -8px; right: -8px; padding: 0; width: 20px; height: 20px;" onclick="clearImageSelection()">
                                    <i class="bi bi-x"></i>
                                </button>
                            </div>
                            <input type="file" name="image" id="imageInput" accept="image/*" class="d-none">
                            <button type="button" class="btn btn-outline-secondary" id="imageUploadBtn" title="Upload image">
                                <i class="bi bi-paperclip"></i>
                            </button>
                            <button type="submit" class="btn btn-success" id="sendBtn">
                                <i class="bi bi-send"></i>
                            </button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let lastMessageId = {{ last_message_id }};
    let isPolling = false;
    let pollTimeout = null;

    // Debug info: print farmer id and whoami for troubleshooting (safe)
    console.log('[CHAT DEBUG] Expert chat page loaded. farmer.id=', {{ farmer.id }}, 'url=', window.location.href);
    fetch('/auth/whoami').then(r=>r.json()).then(function(d){ console.log('[CHAT DEBUG] whoami', d); }).catch(function(e){ console.error('[CHAT DEBUG] whoami fetch error', e); });

    // Auto-scroll to bottom
    function scrollToBottom() {
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Initial scroll
    scrollToBottom();

    // Function to add new message to chat
    function addMessage(messageData) {
        const chatMessages = document.getElementById('chatMessages');

        // Remove empty state if exists
        const emptyState = chatMessages.querySelector('.text-center.text-muted');
        if (emptyState) {
            emptyState.remove();
        }

        // Create message element with ID for deduplication
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${messageData.sender_role}`;
        messageDiv.setAttribute('data-msg-id', messageData.id);

        // Build inner HTML with optional image
        let innerHTML = `<div>${escapeHtml(messageData.message)}</div>`;
        if (messageData.image_path) {
            const imgSrc = messageData.image_path.startsWith('blob:')
                ? messageData.image_path
                : "{{ url_for('static', filename='') }}" + messageData.image_path;
            // Add onerror handler to handle missing images gracefully
            innerHTML += `<div class="chat-image"><img src="${imgSrc}" alt="Chat image" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27200%27 height=%27150%27%3E%3Crect fill=%27%23ddd%27 width=%27200%27 height=%27150%27/%3E%3Ctext x=%2750%25%27 y=%2750%25%27 dominant-baseline=%27middle%27 text-anchor=%27middle%27 font-family=%27Arial%27 font-size=%2714%27 fill=%27%23999%27%3EImage not found%3C/text%3E%3C/svg%3E'"></div>`;
        }
        innerHTML += `<div class="message-time">${messageData.time_display}</div>`;
        messageDiv.innerHTML = innerHTML;

        chatMessages.appendChild(messageDiv);
        scrollToBottom();
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Long-polling function
    function pollForNewMessages() {
        if (isPolling) return;

        isPolling = true;

        const pollUrl = `/expert/chat/{{ farmer.id }}/poll?last_message_id=${lastMessageId}`;
        console.log('[CHAT] Expert polling:', pollUrl);

        fetch(pollUrl)
            .then(response => response.json())
            .then(data => {
                isPolling = false;

                if (data.new_messages && data.new_messages.length > 0) {
                    console.log('[CHAT] Received', data.new_messages.length, 'new messages');
                    // Deduplicate by ID to avoid rendering same message twice
                    const existingIds = new Set();
                    document.querySelectorAll('.message[data-msg-id]').forEach(el => {
                        existingIds.add(parseInt(el.getAttribute('data-msg-id')));
                    });

                    // Add new messages
                    data.new_messages.forEach(msg => {
                        // Skip our own messages and duplicates
                        if (msg.sender_role === 'expert' || existingIds.has(msg.id)) {
                            console.log('[CHAT] Skipping message id', msg.id, 'role:', msg.sender_role);
                            return;
                        }
                        addMessage(msg);
                        existingIds.add(msg.id);
                    });

                    lastMessageId = data.last_message_id;

                    // Show notification sound/visual feedback
                    if (data.new_messages[0].sender_role === 'farmer') {
                        // Play notification sound (optional)
                        // new Audio('/static/sounds/notification.mp3').play();
                    }
                }

                // Continue polling
                pollTimeout = setTimeout(pollForNewMessages, 2000); // Poll every 2 seconds
            })
            .catch(error => {
                console.error('Polling error:', error);
                isPolling = false;
                // Retry after 5 seconds on error
                pollTimeout = setTimeout(pollForNewMessages, 5000);
            });
    }

    // Start polling when page loads
    window.addEventListener('load', () => {
        pollForNewMessages();
    });

    // Stop polling when page is hidden
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (pollTimeout) {
                clearTimeout(pollTimeout);
                pollTimeout = null;
            }
        } else {
            pollForNewMessages();
        }
    });

    // Update unread count badge in navigation
    function updateUnreadBadge() {
        fetch('/expert/chat/unread-count')
            .then(response => response.json())
            .then(data => {
                const badge = document.getElementById('chatUnreadBadge');
                if (badge) {
                    if (data.unread_count > 0) {
                        badge.textContent = data.unread_count;
                        badge.style.display = 'inline-block';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            })
            .catch(error => console.error('Error updating badge:', error));
    }

    // Update badge every 10 seconds
    setInterval(updateUnreadBadge, 10000);
    updateUnreadBadge();

    // Image Preview Logic
    const imageInput = document.getElementById('imageInput');
    const previewContainer = document.getElementById('imagePreviewContainer');
    const imagePreview = document.getElementById('imagePreview');
    const imageUploadBtn = document.getElementById('imageUploadBtn');

    imageUploadBtn.addEventListener('click', function () {
        imageInput.click();
    });

    imageInput.addEventListener('change', function () {
        const file = this.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                imagePreview.src = e.target.result;
                previewContainer.classList.remove('d-none');
            }
            reader.readAsDataURL(file);
        } else {
            clearImageSelection();
        }
    });

    function clearImageSelection() {
        imageInput.value = '';
        imagePreview.src = '';
        previewContainer.classList.add('d-none');
    }

    // Handle form submission - add message immediately to UI
    document.getElementById('chatForm').addEventListener('submit', function (e) {
        e.preventDefault(); // Prevent default form submission

        const messageInput = document.getElementById('messageInput');
        const message = messageInput.value.trim();
        const imageFile = imageInput.files[0];

        // Allow sending if either message or image is present
        if (message || imageFile) {
            // Optimistic UI update
            const tempId = Date.now();
            const tempMessage = {
                id: tempId,
                message: message || (imageFile ? "Sent an image" : ""),
                sender_role: 'expert',
                image_path: imageFile ? URL.createObjectURL(imageFile) : null,
                time_display: new Date().toLocaleString('en-US', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                })
            };
            addMessage(tempMessage);
            messageInput.value = '';
            clearImageSelection();

            // Send to server
            const formData = new FormData();
            formData.append('message', message);
            if (imageFile) {
                formData.append('image', imageFile);
            }

            console.log('[CHAT] Expert submitting message:', message.substring(0, 50), 'with image:', !!imageFile);

            fetch(window.location.href, {
                method: 'POST',
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Message saved successfully
                        console.log('[CHAT] Message sent successfully, id:', data.data.id);
                        // IMPORTANT: Update lastMessageId so polling doesn't pick up our own message again
                        if (data.data && data.data.id) {
                            lastMessageId = data.data.id;
                            // Mark the optimistic UI message with the real ID from server
                            const tempMsg = document.querySelector(`.message[data-msg-id="${tempId}"]`);
                            if (tempMsg) {
                                tempMsg.setAttribute('data-msg-id', data.data.id);
                                console.log('[CHAT] Updated temp message ID from', tempId, 'to', data.data.id);
                            }
                        }
                    } else {
                        console.error('[CHAT] Error sending message:', data.message);
                        // Optional: Show error to user
                    }
                })
                .catch(error => {
                    console.error('[CHAT] Fetch error:', error);
                });
        }
    });
</script>
{% endblock %}